import requests
from requests.exceptions import RequestException
import json
import os
import sys
import platform
import re
from datetime import datetime

# Constants
BASE_URL = "http://172.32.0.11:32768/api"
GET_COMMANDS_URL = f"{BASE_URL}/get"
CMD_COMMANDS_URL = f"{BASE_URL}/cmd"
COMMANDS_PER_PAGE = 5

def clear_screen():
    """Clears the terminal screen for a fresh menu display."""
    os.system('cls' if platform.system() == 'Windows' else 'clear')

def fetch_commands():
    """Fetches the list of commands from the API.

    Returns:
        list: A list of command dictionaries.
    """
    try:
        response = requests.get(GET_COMMANDS_URL)
        response.raise_for_status()
        return response.json().get('commands', [])
    except requests.RequestException as e:
        print(f"Error fetching commands: {e}")
        return None

def display_menu(commands, level=0, page=1):
    """Displays the command menu with pagination.

    Args:
        commands (list): List of command dictionaries.
        level (int): The current menu level.
        page (int): The current page number.

    Returns:
        bool: True if commands were displayed successfully, else False.
    """
    start_index = (page - 1) * COMMANDS_PER_PAGE
    end_index = start_index + COMMANDS_PER_PAGE
    paginated_commands = commands[start_index:end_index]
    
    clear_screen()
    print("\n" + ("=" * (level + 1)) + " Menu " + ("=" * (level + 1)))
    
    if not paginated_commands:
        print("No more commands to display.")
        return False

    for idx, command in enumerate(paginated_commands):
        description = command.get('description', 'No description available.')
        command_id = command.get('id', 'No ID')
        print(f"{start_index + idx + 1}: {description} ({command_id})")

    print(f"{len(paginated_commands) + 1}: Next Page")
    
    if level == 0:
        print(f"{len(paginated_commands) + 2}: Exit")
    else:
        print(f"{len(paginated_commands) + 2}: Back to previous menu")

    return True

def is_valid(input_value, arg_type):
    """Validates user input based on field type.

    Args:
        input_value (str): The value to validate.
        arg_type (str): The type of the argument.

    Returns:
        bool: True if input is valid, else False.
    """
    if '@' in arg_type:
        arg_type = arg_type.split('@')[-1]
    
    if arg_type == "str":
        if input_value.strip() == "":
            print("Hint: Input should be a non-empty string.")
            return False
        return True

    if arg_type == "int" and re.match(r"-?\d+", input_value):
        return True
    elif arg_type == "unsigned" and re.match(r"\d+", input_value):
        return True
    elif arg_type == "date":
        try:
            datetime.strptime(input_value, "%Y-%m-%d")
            return True
        except ValueError:
            print("Hint: Input should be a valid date in the format YYYY-MM-DD.")
            return False
    elif arg_type == "time":
        try:
            datetime.strptime(input_value, "%H:%M")
            return True
        except ValueError:
            print("Hint: Input should be a valid time in HH:mm format.")
            return False
    elif arg_type == "duration" and re.match(r"^\d+h \d+m$", input_value):
        return True

    print(f"Hint: Unknown argument type: {arg_type}")
    return False

def get_user_input(field_info):
    """Prompts user for input based on field information.

    Args:
        field_info (dict): Field information including name, type, etc.

    Returns:
        str: User input value or default value.
    """
    field_name = field_info['field']
    description = field_info.get('description', field_name)
    field_type = field_info['type']
    mandatory = field_info.get('mandatory', False)
    modifier = field_info.get('modifier')

    if modifier == "auto":
        return field_info.get('defaultValue', '')

    while True:
        user_input = input(f"Enter {description} ({field_type}): ")
        
        if mandatory and user_input.strip() == "":
            print(f"{description} is mandatory. Please provide a value.")
            continue
        
        if not mandatory and user_input.strip() == "":
            return field_info.get('defaultValue', '')

        if is_valid(user_input, field_type):
            return int(user_input) if field_type == "int" else user_input

        print("Invalid input. Please try again.")

def create_payload(args_info):
    """Creates a JSON payload from user inputs.

    Args:
        args_info (dict): Dictionary of field information.

    Returns:
        dict: Dictionary representing the payload.
    """
    payload = {}
    
    for field_key, field_info in args_info.items():
        user_input = get_user_input(field_info)
        payload[field_key] = user_input
    
    return payload

def run_command(selected_command, root_identifier):
    """Executes the command with the provided identifier.

    Args:
        selected_command (dict): Dictionary of the selected command.
        root_identifier (str): Identifier from the root.
    """
    payload = {
        "identifier": root_identifier,
        "commands": [{
            "args": {},
            "data": {},
            "id": selected_command['action']
        }]
    }

    if 'args' in selected_command:
        for field_key, field_info in selected_command['args'].items():
            user_input = get_user_input(field_info)
            payload['commands'][0]['args'][field_key] = field_info
            if user_input is not None:
                payload['commands'][0]['data'][field_key] = user_input

    try:
        response = requests.post(CMD_COMMANDS_URL, json=payload)
        response.raise_for_status()
        print("Response from the server:")
        print(json.dumps(response.json(), indent=2))
    except requests.RequestException as e:
        print(f"Error sending command: {e}")

def handle_selection(commands, level=0):
    """Handles user selection from the menu.

    Args:
        commands (list): List of command dictionaries.
        level (int): The current menu level.
    """
    page = 1

    while True:
        displayed = display_menu(commands, level, page)

        if not displayed:
            break

        selection = input("Select a command by number: ")
        
        try:
            selection = int(selection)
        except ValueError:
            print("Invalid selection, please enter a number.")
            continue

        if level == 0 and selection == len(commands) + 2:
            print("Exiting the program.")
            exit(0)
        elif selection == len(commands) + 1:
            page += 1
            continue
        elif selection == len(commands) + 2:
            return

        if 1 <= selection <= len(commands):
            selected_command = commands[selection - 1]
            if 'commands' in selected_command:
                handle_selection(selected_command['commands'], level + 1)
            else:
                root_identifier = selected_command.get('id', 'root')
                run_command(selected_command, root_identifier)
                input("Press Enter to continue...")
        else:
            print("Invalid selection, please try again.")

def main():
    """Main function to execute the command-line interface."""
    commands = fetch_commands()
    if commands is None:
        return
    
    while True:
        clear_screen()
        display_menu(commands)
        handle_selection(commands)

def check_service_availability():
    try:
        response = requests.get(GET_COMMANDS_URL, timeout=5)
        response.raise_for_status()  # Raises an error for bad responses (4xx and 5xx)
        print("Service is available.")
        return True
    except RequestException as e:
        print(f"Service is not available")
        return False

if __name__ == "__main__":
    # Example usage
    if check_service_availability():
        main()
    else:
        print("Exiting due to service unavailability.")
        exit(1)
    
