#!/bin/bash

# Function to get the command based on the provided exec_cmd
# @param $1 The key to look up the command
# @return The corresponding command string if found, else an empty string
get_command() {
    # Declare the array with key-value pairs as a string
    local commands="
mvn@maven:mvn -f EventManagementApp/EventManApp
javac@maven:javac
mysql@mysql:mysql -u root -pmypass
cli@sshd:bash
remotemysql@sshd:mysql -u eventman -peventmanpass -h 172.32.0.16"

    input="$1"
    echo "$commands" | awk -F: -v key="$input" '$1 == key { print $2 }'
}

# Function to run the Maven command inside the Docker container
# @param $1 The command to execute (e.g., mvm@maven, mysql@mysql)
# @param $# Additional arguments to be passed to the command
# @return 0 if the command runs successfully, non-zero exit code otherwise
container_run() {
    # Initialize an array to hold directive names
    local directives=()
    local non_directives=()
    local exec_cmd="$1"
    local docker_name=$(echo "$1" | awk -F@ '{ print $2 }')
    shift  # Shift to process the remaining arguments

    # Retrieve the command based on exec_cmd
    local command_to_run
    command_to_run=$(get_command "$exec_cmd")

    if [ -z "$command_to_run" ]; then
        echo "Command not found for: $exec_cmd"
        return 1
    fi

    # Loop through all provided arguments
    for arg in "$@"; do
        if [[ $arg == --* ]]; then
            # If the argument is a directive, add it to the array
            directives+=("$arg")
        else
            non_directives+=("$arg")
        fi
    done

    # Shift out the processed directives
    set -- "${non_directives[@]}" # Retain only the non-directive arguments for the command

    local output=""
    local exit_code=1

    # Check for the --noit directive and run the appropriate Docker command
    if [[ " ${directives[@]} " =~ " --noit " ]]; then
        # Capture the output of the Docker command without TTY
        set -x
        output=$(docker exec "$docker_name" $command_to_run "$@")
        set +x
        exit_code=$?
    elif [[ " ${directives[@]} " =~ " --it " ]]; then
        # Run with -it option for interactive mode
        set -x
        docker exec -it "$docker_name" $command_to_run "$@"
        set +x
        exit_code=$?
    elif [[ " ${directives[@]} " =~ " --i " ]]; then
        # Run with -i only for interactive input
        set -x
        docker exec -i "$docker_name" $command_to_run "$@"
        set +x
        exit_code=$?
    else
        # Default: use -it for interactive unless specified otherwise
        set -x
        docker exec -it "$docker_name" $command_to_run "$@"
        set +x
        exit_code=$?
    fi

    # Print the output if the exit code is not 0
    if [ $exit_code -ne 0 ]; then
        echo "Error running Docker command:"
        echo "$output"
    elif [[ ! " ${directives[@]} " =~ " --quiet " ]]; then
        # If --quiet is not present, print the output anyway
        echo "$output"
    fi

    # Return the exit status
    return $exit_code
}

# Function to check the status of a Docker container
# @param $1 The name of the container to check (e.g., maven, mysql)
# @param $# Additional arguments to be passed to the command
# @return 0 if the container is running, non-zero exit code otherwise
container_status() {
    # Initialize an array to hold directive names
    local directives=()
    local non_directives=()
    local interactive_flag="-it"  # Default to interactive mode

    # First argument is the name of the container (e.g., maven, mysql)
    local container_name="$1"
    shift  # Shift to process the remaining arguments

    # Loop through all provided arguments
    for arg in "$@"; do
        if [[ $arg == --* ]]; then
            # If the argument is a directive, add it to the array
            directives+=("$arg")
        else
            non_directives+=("$arg")
        fi
    done

    # Shift the processed arguments
    set -- "${non_directives[@]}" # Retain only the non-directive arguments for the command

    local output=""
    local exit_code=1

    # Check if Docker is running and if the specified container exists
    if [ "$(docker ps -q -f name="$container_name")" ]; then
        echo "Docker container '$container_name' is available."
        # Capture the output of the Docker command
        output=$(docker inspect --format='{{.Name}} - {{.State.Status}}' "$container_name")
        exit_code=$?
    elif [[ ! " ${directives[@]} " =~ " --quiet " ]]; then
        echo "$output"
    fi

    # Print the output if the exit code is not 0
    if [ $exit_code -ne 0 ]; then
        echo "Docker container '$container_name' is not running or does not exist."
        echo "Error running Docker command:"
        echo "$output"
    else
        # Print the output if successful and not in quiet mode
        if [[ ! " ${directives[@]} " =~ " --quiet " ]]; then
            echo "$output"
        fi
    fi

    # Return the exit status
    return $exit_code
}

# Function to run Maven command in a Docker container
# @param $# Additional arguments to be passed to the Maven command
# @return The exit status of the container_run function
mvn() {
    container_run mvn@maven "$@"
    return $?
}

# Function to run Java compiler in a Docker container
# @param $# Additional arguments to be passed to the javac command
# @return The exit status of the container_run function
javac() {
    container_run javac@maven "$@"
    return $?
}

# Function to run Java command in a Docker container
# @param $# Additional arguments to be passed to the java command
# @return The exit status of the container_run function
javad() {
    container_run java@maven "$@"
    return $?
}

# Function to run MySQL command in a Docker container
# @param $# Additional arguments to be passed to the MySQL command
# @return The exit status of the container_run function
mysql() {
    container_run mysql@mysql "$@"
    return $?
}

# Function to run CLI command in a Docker container
# @param $# Additional arguments to be passed to the CLI command
# @return The exit status of the container_run function
cli() {
    container_run cli@sshd "$@"
    return $?
}

# Function to run remote MySQL command in a Docker container
# @param $# Additional arguments to be passed to the remote MySQL command
# @return The exit status of the container_run function
remotemysql() {
    container_run remotemysql@sshd "$@"
    return $?
}

# Main code block
# Check the status of specified containers
container_status "maven"
container_status "mysql"
container_status "sshd"
