---
#...
# Git-deck card header
# OBS! DON'T REMOVE CARD HEADERS
#...
Title: Create a pre-action to merge the dev branch to the main branch.
Tags: EventMan STEP1
Creator:
AssignedTo:
# Time tracker settings
tartAt:
EndAt:
---
The goal of this card is to push some files (from a list) push to the `develop`branch to the main automatically.

# DOD (definition of done):
A GitHub action is developed and implemented.

# TODO:
- [x] 1. Create an GitHub action for the `develop` to auto-push files to the `main`

# Reports:
* The current action, `generate-deck.yml` was updated to work only if the branch is `main`. So even the action file is added to other branches such as develop, it does nothing.
> * However I thing removing a file ( in this case an YAML action file) that is not used or ignored makes a repo more clear.
> * For now it will be kept for a while but it will be removed from `develop` when designing actions are completely done.
* A new action name `auto-merge-changes.yml` was added to the `develop`  branch to read a list of files and folders from a file named `.gitmainauto` from the root of the `develop` branch and push them to main automatically after pushing to the `develop`

## Updating rge design for git branches and their connections
 
* During working on workflow automation' action it was realized there is no need copy/merge git-deck (`.pm/`) files and its related files such as `.gitdefault` (and potentially `.gitignore`) from the `develop` branch to the `main` branch
 
> * git-dek and kanban boards a part of develop flows, not a part of the code.
> * The `main` branch serves as a repository for the ready to use code (beta version of the final code), which is used for intermediate testing of integrations between various components of the project. Once the code passes all tests, it will be merged into the 'release' branch.
> * The `release` branch serves as a repository for the final code (ready to implement).

* So according to this new design, the only files that needs to be merged to the `main` automatically is `README.md`.
* There is also no needs to generate `DECK.md` on the `main` branch. The main is not contained git-deck `.pm/` files anymore. So the action to generate DECK on the main can removed.
* The action to generate DECK is run on the `develop` and push the generated `DECK.md`to the `main`

```mermaid
graph TD
    A[**`develop branch`**] -->|Push auto-generated files| B[**`main branch`**]
    A -->|Push default files| B
    A -->|Run Tests| D{Tests Passed?}
    D -->|Yes| B
    D -->|No| A
    B -->|Run Tests| E{Tests Passed?}
    E -->|Yes| C[**`release branch`**]
    E -->|No| B
    C -.->|Implement| F((production))
```

## Findings

### multi-jobs' action and jobs orders
There are several method that can be used to run multi-actions in a repo

1. If the actions can run concurrently without conflicts, creating actions YAML files and adding them to GitHub Workflows work fine.
2. If the actions must run in a specific order or cannot run in parallel, it needs to trigger them sequentially by each other.

### GitHub Job Ordering
* Define job ordering in a workflow

```name: CI Workflow

on:
  push:
    branches:
      - develop

jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - name: Step 1
        run: echo "This is Job 1"

  job2:
    runs-on: ubuntu-latest
    needs: job1  # This job will wait for job1 to finish
    steps:
      - name: Step 2
        run: echo "This is Job 2"

  job3:
    runs-on: ubuntu-latest
    needs: [job1, job2]  # This job will wait for both job1 and job2 to finish
    steps:
      - name: Step 3
        run: echo "This is Job 3"
```

* Define Workflows in Separate Files
> * Workflow A (workflow-a.yml):
>```
>name: Workflow A
>
>on:
>  push:
>    branches:
>      - develop
>
>jobs:
>  job_a:
>    runs-on: ubuntu-latest
>    steps:
>      - name: Step A
>        run: echo "Running Workflow A"
>```
> * Workflow A (workflow-a.yml):
>```
>name: Workflow B
>
>on: 
>  workflow_run:
>    workflows: ["Workflow A"]  # Depends on Workflow A
>    types:
>      - completed
>
>jobs:
>  job_b:
>    runs-on: ubuntu-latest
>    steps:
>      - name: Step B
>        run: echo "Running Workflow B after Workflow A"
>```

* **OBS!** In multi-trigger actions, the initial trigger always activates the actions. For example if in the `on` section `push` and `workflow_run` both are defined as triggers (example below `Auto-Merge changes`) and also the second action (`Generate DECK.md`) is defined to be activates by `push`, the first one (`Auto-Merge changes`) will not wait for the second (`Generate DECK.md`). Both start in the same time by `push`.
```
name: Auto-Merge changes

on:
  push:
    branches:
      - develop  # Commit changes here will trigger the action
  workflow_run:
    workflows: ["Generate DECK.md"]  # Depends on 
    types:
      - completed  # Ensure this is set to completed
```

* **OBS!** Regardless how actions are added, all in a file or in several files, if no order or dependency are defined, all action will be run in their isolated workflow in a parallel way.

### Define action orders and trigger actions by each other
## Three methods to chain GitHub Actions

1. **Separate workflows (cross-workflow pipeline)**  
   - Create distinct workflows and chain them using `workflow_run` or `repository_dispatch` so one workflow triggers the next.  
   - Example: workflow A finishes → workflow B starts via `workflow_run` with `types: [completed]`.  
   - **Limitations:** `workflow_run` only triggers when the upstream workflow runs on the default branch (commonly main); passing complex artifacts requires explicit upload/download; cross-repo triggers need extra auth (PAT or repository_dispatch).

2. **Single workflow — ordered jobs/steps**  
   - Define multiple jobs in one workflow and enforce order with `needs` (or use ordered steps within a job).  
   - Use `concurrency`, `if` conditions, or matrix strategy to control parallelism and conditional execution.  
   - **Limitations:** Very large workflows become harder to maintain; long-running workflows may delay other jobs; limited cross-repo orchestration.

3. **Orchestrator / reusable pipeline action**  
   - Use a reusable workflow (`workflow_call`) or a custom orchestrator action that triggers workflows via the GitHub API/gh to run and coordinate other workflows (including cross-repo).  
   - Offers dynamic branching, retries, and centralized control; requires handling auth if using the API.  
   - **Limitations:** Custom orchestrator actions need a PAT for API triggers (manage secrets/permissions); more complex to implement; API rate limits and auth scopes apply. Reusable workflows cannot be called across forks without extra configuration.

Summary table

| Method | When to use | Key idea | Example trigger | Key limitations |
|---|---:|---|---|---|
| 1) Separate workflows | Clear stage separation, independent retries | Chain workflows using `workflow_run` or `repository_dispatch` | workflow A → workflow B via `workflow_run` | `workflow_run` only for default branch; artifact passing harder; cross-repo auth needed |
| 2) Single workflow | Simple pipeline, easy artifact sharing | Define jobs/steps in one workflow; use `needs` | jobA → jobB (needs: [jobA]) | Harder to maintain when large; less flexible cross-repo |
| 3) Orchestrator / reusable pipeline | Complex runtime orchestration or cross-repo control | Use `workflow_call` or custom action to orchestrate runs via API | Orchestrator triggers workflow_dispatch or calls reusable workflow | Requires PAT/auth for API; possible rate limits; added complexity |

Minimal examples

1) Single workflow (ordered jobs)
```yaml
name: CI
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps: [...]
  test:
    runs-on: ubuntu-latest
    needs: [build]
    steps: [...]
  deploy:
    runs-on: ubuntu-latest
    needs: [test]
    steps: [...]
```

2) Separate workflows (workflow_run)
workflow A (build):
```yaml
on: [push]
# produces artifacts
```
workflow B (test/deploy):
```yaml
on:
  workflow_run:
    workflows: ["workflow A name"]
    types: [completed]
# Note: triggers only when workflow A ran on the default branch
```

3) Orchestrator / reusable pipeline
- Reusable pipeline (pipeline.yml):
```yaml
on:
  workflow_call:
    inputs:
      run-tests: { type: boolean, required: false, default: true }
jobs:
  build: {...}
  test:
    needs: [build]
    if: ${{ inputs.run-tests }}
  deploy:
    needs: [test]
```
- Caller workflow (calls pipeline):
```yaml
on: [workflow_dispatch]
jobs:
  call-pipeline:
    uses: ./.github/workflows/pipeline.yml
    with:
      run-tests: true
```
Or: use a custom orchestrator action/step that calls the GitHub API (`workflow_dispatch`) or `gh` to trigger workflows across repos; remember to store PAT in secrets.

Recommendation
- Prefer single workflow for small/simple pipelines and easy artifact sharing.  
- Use separate workflows with `workflow_run` when you want stage separation and independent retries, but watch default-branch limitations.  
- Use reusable workflows (`workflow_call`) or a custom orchestrator action for reusable pipelines or complex cross-repo orchestration; manage auth and rate limits carefully.


* **OBS!** **GitHub only fires workflow_run for workflows whose workflow file exists on the repository default branch (usually main)**


* References
> * https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows
