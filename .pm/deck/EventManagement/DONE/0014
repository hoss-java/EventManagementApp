---
#...
# Git-deck card header
# OBS! DON'T REMOVE CARD HEADERS
#...
Title: Implement a DB layer.
Tags: EventMan STEP2
Creator:
AssignedTo:
# Time tracker settings
tartAt:
EndAt:
---
The goal of this card is to implement a DB layer

# DOD (definition of done):

# TODO:
- [x] 1. Spike to find ways to implement a data manager layer

# Reports:
* I realize it needs to apply many changes on the current designed to apply an efficient data layer.
* The current object handlers use an object named EMObject, the object has already an identifier and handlers set it when they create an object. It means objects have already an identifier but it is not use.
* In the current design each handler creates its own EMObject list. So there is nothing unrelated to the handler in the list, they don't need to check it!
* Howw it looks like now
> * The core is based on a multi  key-value object named BaseObject, base object it self use a internal sub object to manage filed (key-value : String-<value-type>). This object dose not care about teh number of fields and fields name/type or owner. Its only check names to avoid key duplication.
> * EMObject extends BaseObject and adds a fields map and an id to specify objects. 
>> * It uses a mao based on EMObjectField which is the class to define field attributes such as type, modifier, default value and so on.
>> * An EMObject stores a key-value base data based an JSON source according to a field map. In other words it get a field map and an JSON source, then creates a BaseObject from THE JSON source according to the fields map. It means values stored on the JSON as String is validated and converted to types defined via the fields map,
>> * Additional key-vlues(s) on the JSON that are not covered by the fields maps are ignored.
>> * So EMObject contains , an **id**, **fields** map and also **fields key-value(s) data**
>> * It has also a validator method that can be override if needed. For now validator supports **str**, **int**, **unsigned**, **date**, **time** and **duration** only.
>>> TOFIX ->>**isValidForAddition**

* All variables and files with name EM were change to KV to make it more generic name.
* Add and remove objects can be moved from all type handlers to KVObjectHandler, It just needs to know id for both add and remove, and also which object(s) to remove
* 

```sql
-- Define user, password, and database
-- Define user, password, and database
SET @username := 'eventman';
SET @password := 'eventman-pass';
SET @database := 'eventman';
SET @ip_range := '172.32.0.%';

-- Drop the user if it exists
SET @drop_user_stmt = CONCAT('DROP USER IF EXISTS ''', @username, '''@''', @ip_range, '''');
PREPARE stmt FROM @drop_user_stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Create the user
SET @create_user_stmt = CONCAT('CREATE USER ''', @username, '''@''', @ip_range, ''' IDENTIFIED BY ''', @password, '''');
PREPARE stmt FROM @create_user_stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Create the database
SET @create_database_stmt = CONCAT('CREATE DATABASE IF NOT EXISTS ', @database);
PREPARE stmt FROM @create_database_stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Grant privileges to the user
SET @grant_stmt = CONCAT('GRANT ALL PRIVILEGES ON ', @database, '.* TO ''', @username, '''@''', @ip_range, '''');
PREPARE stmt FROM @grant_stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Optional: Flush privileges to ensure changes take effect
FLUSH PRIVILEGES;

-- Verify the created user and display grants
SET @verify_stmt = CONCAT('SHOW GRANTS FOR ''', @username, '''@''', @ip_range, '''');
PREPARE stmt FROM @verify_stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

-- Instead, you can directly execute SHOW GRANTS
-- SHOW GRANTS FOR 'eventman'@'172.32.0.%';

-- End of script

```

## how it works
1 . At start (the first time) a schema is loaded from `subject.xml`
>```xml
><subjects>
>    <subject identifier="event">
>        <field name="id" field="id" type="int" mandatory="true" modifier=">auto" defaultValue="1"/>
>        <field name="title" field="title" description="Title" type="str" >mandatory="true" modifier="user" defaultValue="workshop"/>
>        <field name="location" field="location" description="Location" >type="str" mandatory="false" modifier="user" defaultValue="here"/>
>        <field name="capacity" field="capacity" description="Capacity" >type="unsigned" mandatory="false" modifier="user" defaultValue="1">/>
>        <field name="date" field="date" description="Date" type="date" >mandatory="false" modifier="user" defaultValue="2023-10-01"/> <!--> Example Date -->
>        <field name="starttime" field="starttime" description="Time" type=>"time" mandatory="false" modifier="user" defaultValue="00:00:00"/>
>        <field name="duration" field="duration" description="Duration" >type="duration" mandatory="false" modifier="user" defaultValue=">PT0H"/>
>    </subject>
>    <subject identifier="participant">
>        <field name="id" field="id" type="int" mandatory="true" modifier=">auto" defaultValue="1"/>
>        <field name="name" field="name" description="Name" type="str" >mandatory="true" modifier="user" defaultValue=""/>
>        <field name="email" field="email" description="Enaik" type="str" >mandatory="false" modifier="user" defaultValue=""/>
>    </subject>    
>    <subject identifier="organize">
>        <field name="id" field="id" type="int" mandatory="true" modifier=">auto" defaultValue="1"/>
>        <field name="eventid" field="eventid@id:event.title" description=">Event" type="int@str" mandatory="true" modifier="user" >defaultValue=""/>
>        <field name="participantid" field=">participantid@id:participant.name" description="Participant" type=>"int@str" mandatory="false" modifier="user" defaultValue=""/>
>    </subject>
></subjects>
>
>```
2. Subjects are stored in a table named `kvsubjects`, each subject become as a row in the table.
3. For each subject an object table is created (in the first time)
4. In other words an object table is a data table, an the subject table define how to read object tables. It means to read/write/remove object tables, subject rows are used.

## What it supports for now
* A Storage manager define what the storage target is
* For now it supports memory, file and sql (sql server and sqlite)
* **OBS!** sqlite has been not tested yet!

## What more to do
1. Adding tests
2. Adding a MongoSB or similar non-sql db
3. Add new interfaces (ssh, REST)
4. Reorganize files in a correct way for example in a Spring way
5. Try to implement a web base Frontend

## Issues
1. In the case of db it cant close db connections in a correct way
2. Secret keys are stored in a text file which is easy to read